/* (C) Copyright 2013 by Oliver Cordes
        - ocordes ( at ) astro ( dot ) uni-bonn ( dot ) de


    This file is part of acs-cte-project

    animation is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    animation is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
     You should have received a copy of the GNU General Public License
    along with animation.  If not, see <http://www.gnu.org/licenses/>. 

*/

/* acs_clock_charge_image.c

   written by: Oliver Cordes 2013-01-22
   changed by: Oliver Cordes 2013-04-08

   $Id: acs_clock_charge_image.c 416 2013-03-18 17:21:52Z ocordes $

*/

/*
#define __adebug
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>

#include <sys/time.h>
#include <sys/resource.h>

#include "output.h"


double get_difftime( struct timeval start, struct timeval end )
{
  double seconds;
  double microseconds;

  seconds = end.tv_sec - start.tv_sec;
  microseconds = end.tv_usec - start.tv_usec;

  if ( microseconds < 0 )
    {
      seconds -= 1;
      microseconds = 1000000 - microseconds;
    }
  
  microseconds /= 1e6;
  
  return ( seconds + microseconds );
}


int  get_sparse_pixels( float *image, int width, int height, float limit )
{
  int totpix;
  int i;
  int nr = 0;

  totpix = width * height;

  for (i=0;i<totpix;i++)
    if ( ( image[i] > 0.0 ) && ( image[i] < limit ) )
      nr++;

  return nr;
}


double get_sum_double_array( double *array, int width, int height )
{
  double sum = 0.0;
  
  int    totel;
  int    i;

  totel = width * height;

  for (i=0;i<totel;i++)
    sum += array[i];

  return sum;
}


float max_column( float *image, int width, int height, int column, int start_y, int end_y )
{
  int    pos;
  int    y;

  double max;
  
  
  max = image[(start_y * width) + column];
  for (y=start_y+1;y<end_y;y++)
    {
      pos = ( y * width )  + column;
      if ( image[pos]  > max )
	max = image[pos];
    }

  return max;
}



double *indgen( int count )
{
  int     i;
  double *array;

  array = malloc( count * sizeof( double ) );

  for (i=0;i<count;i++)
    array[i] = i;
  
  return array;
}


double *gen_frac( int cheight, double dheight )
{
  int     i;
  double *array;

  array = malloc( cheight * sizeof( double ) );
  for (i=0;i<cheight-1;i++)
    array[i] = 1.0;
  array[cheight-1] = dheight - (cheight-1);
  
  return array;
}



/* doing acs_clock_charge_image on float values */



void acs_clock_charge_image( float  *image,
			     int     image_width,
			     int     image_height,
			     int     express,
			     double  well_depth,
			     double  well_notch_depth,
			     double  well_fill_power,
			     int     n_species,
			     double *trap_density,
			     double *trap_lifetime,
			     double  trap_initial_density,
			     double  trap_permanent_rate,
			     double  trap_removable_rate,
			     int     *xrange,
			     int     *yrange,
			     int     quantize_traps,   /* intern ask Richard */
			     int     quantize_charge,  /* intern ask Richard */
			     int     n_iterations,
			     int    *pn_levels,
			     int     n_phases,         /* intern ask Richard */
			     int     active_phase
			     )
{
  /* CTE variables */
  double  traps_total;
  int     n_levels;
  int     n_levels_traps;
  double *n_electrons_per_trap;
  int    *express_multiplier;
  int    *p_express_multiplier;
  int     i_express;
  double *exponential_factor;
  double *release;
  double  total_exp_trap;
  double *traps;
  double *capture;
  double  total_capture;
  double *freec;
  double *trail;
  double  well_range;
  double  max_height;
  int     height;
  int     cheight;
  double  dheight;
  
  int     sparse_pixels;  

  double *height_frac; 

  int     start_x, start_y, end_x, end_y;
  int     i_column, i_pixel;


  /* helpers */
  int     i, j;
  double  d;
  /*int     count = 0; */
  double  sum;

  /* time measurement */
  struct timeval start_time;
  struct timeval temp_time;
  double  diff_time;
  double  eta_time;

  struct rusage  cpu_start_time;
  struct rusage  cpu_temp_time;
  double  cpu_diff_time;


  /* copy dimension parameters */
  if ( xrange == NULL )
    {
      start_x = 0;
      end_x = image_width;
    }
  else
    {      
      start_x = xrange[0];
      end_x = xrange[1];
    }
  
  if ( yrange == NULL )
    {
      start_y = 0;
      end_y = image_height;
    }
  else
    {      
      start_y = yrange[0];
      end_y = yrange[1];
    }

  output( 10, "start_x=%i end_x=%i\n", start_x, end_x );
  output( 10, "start_y=%i end_y=%i\n", start_y, end_y );

  traps_total = 0;
  for (i=0;i<n_species;i++)
    traps_total += trap_density[i];

  quantize_traps=0;
  quantize_charge=0;

  /*

    if not keyword_set(n_levels)        then begin 
      if keyword_set(quantize_traps) then n_levels=round(2.0/total(trap_density))>1 else n_levels=10000 
    endif 
  */

  /* if quantize_traps set 
  n_levels = round( 2.0 / traps_total );
  if ( n_levels < 1  )
    n_levels = 1;
  */
  n_levels = 10000; 
  (*pn_levels) = n_levels;

  if ( n_phases > 1 )
    {
      /* do some things for n_phases>1
	 
	 expanding image */
    }

  n_electrons_per_trap = malloc( sizeof( double ) * n_species );
  for (i=0;i<n_species;i++)
    n_electrons_per_trap[i] = trap_density[i] / n_levels;

  sparse_pixels = get_sparse_pixels( image, image_width, image_height, traps_total );

  output( 1, "There are %i pixels containing more traps than charge.\nThe order in which these traps should be filled is ambiguous.\n", sparse_pixels );

  /* skip java */
  /* skip if keyword_set(cdm03) then part */

  /* IDL
  if n_species eq 1 then begin 
		 n_species=2 
                 trap_lifetime=[trap_lifetime,1e-7] 
                 trap_density=[trap_density,0] 
                 n_electrons_per_trap=[n_electrons_per_trap,0] 
  endif ; Catch an error to allow vector operations later

  we have n_species > 1 
  */

  output( 1, "Using Jay Anderson's trick to speed up runtime\n" );

  /* IDL
  express_multiplier=(indgen(yrange[1]+1)+1)##[0,replicate(1,express)]
      for i_express=1,express do 
       express_multiplier[i_express,*]=(express_multiplier[i_express,*]<((yrange[1]+1)*i_express/express))-total(express_multiplier[0:i_express-1,*],1)

  */

  /* express is only 1, so the first line is a simple vector;
     in IDL only the second+... column will be indexed ... strange,
     this is the [0,replicate(1,express)] command
     total(express_multiplier[0:i_express-1,*],1) is also zero for express=1
  */

  /* new code with variable express */
  
  express_multiplier = malloc( express * (image_height+1 ) * sizeof( int ) );
  
  for (i_pixel=0;i_pixel<image_height+1;i_pixel++)
    {
      int d;
      int d2;
      int i_sum = 0;
      for (i_express=0;i_express<express;i_express++)
	{
	  int pos;
	  d = ( i_pixel + 1);
	  d2= ((image_height+1)*(i_express+1))/express;
	  if ( d > d2 )
	    d = d2;

	  d -= i_sum;
	  i_sum += d;

	  pos = (i_express*(image_height+1))+i_pixel;
	  express_multiplier[pos] = d;
	}
     } 
  

  /* old code for express=1 
  express_multiplier = indgen( image_height+1 );
  
  for (i=0;i<image_height;i++)
    {
      express_multiplier[i] += 1.0;
      d = ( image_height+1 );
      if ( express_multiplier[i] > d )
	express_multiplier[i] = d;
    }
  */


  /* IDL
    exponential_factor=(1-exp(-1.0/trap_lifetime))##replicate(1,n_levels)
  */


  /* array structures in general ... 

     in the IDL description we have n_species x something array 
     for traps, release, capture .. 
     Since the something is different for each array it is better to have
     a something x n_species organization in C, so that we can first loop
     over something and then loop over n_species
  */

  exponential_factor = malloc( n_species * n_levels * sizeof( double ) );

  
  for (i=0;i<n_levels;i++)
    for (j=0;j<n_species;j++)
      exponential_factor[(i*n_species)+j] = 1 - exp( -1.0 / trap_lifetime[j] ); 

  /* IDL
    well_range=float(well_depth-well_notch_depth)
  */
  well_range = well_depth - well_notch_depth;

  /* IDL
    traps=fltarr(n_levels,n_species)
  */
  
  /*  IDL
      traps[n_levels,n_species]  
  */
  traps = malloc( n_species * n_levels * sizeof( double ) );

  /* allocate free and trail array */
  freec = malloc( ( end_y - start_y )  * sizeof( double ) );
  trail = malloc( ( end_y - start_y )  * sizeof( double ) );

  /* capture will have max n_species * n_levels elements*/
  capture = malloc( n_species * n_levels * sizeof( double ) );

  /* 
     Swipe a set of charge traps up each column in turn
  */

  /* calculate the total before the loop 
     the IDL code means more, but the resulting arrray
     exponential_factor[0,*]*trap_density is already one dimensional ... 
   */
  total_exp_trap = 0.0;
  for (i=0;i<n_species;i++)
    total_exp_trap += exponential_factor[i] * trap_density[i];



  

  /* debug window */

  /* checked:
     trap_density
     n_electrons_per_trap
     exponential_factor
     n_levels
     n_species
     express = 1 (not implemented inC
     well_range
     well_noth_depth
     well_fill_power
  */
  

  /* initialize the time measurement */
  gettimeofday( &start_time, NULL );
  getrusage( RUSAGE_SELF, &cpu_start_time );

  for (i_column=start_x;i_column<end_x;i_column++)
    {
      /* use the multiplier as a flat array with the "pixel multiplicators"  
	 in a line */
      p_express_multiplier = express_multiplier;
      for (i_express=0;i_express<express;i_express++)
	{
	  /* IDL
	     max_height=(((1+total(exponential_factor[0,*]*trap_density,2))<2)*((max(image[i_column,yrange[0]:yrange[1]])-well_notch_depth)/well_range)^well_fill_power)>0          

	     ; the total means to collapse the 2 dimension only, which means to sum over all values

	     ; shape max_height within 1 and n_levels
	     max_height=1>ceil(n_levels*max_height)<n_levels   
	  */
	  d = max_column( image, image_width, image_height, i_column, start_y, end_y );

	  max_height = (1+total_exp_trap);
	  if ( max_height > 2.0 )
	    max_height = 2.0;
	  max_height = max_height * pow(( (d - well_notch_depth) / well_range ), well_fill_power );

	  if ( max_height < 0.0 )
	    max_height = 0.0;

	  max_height = ceil( max_height * n_levels );
	  if ( max_height < 1.0 )
	    max_height = 1.0;
	  else
	    if ( max_height > n_levels )
	      max_height = n_levels;
      
	  /*output( 1, "max_height=%f\n", max_height ); */
	  
	  /* IDL
	    free=((image[i_column,yrange[0]:yrange[1]]<well_depth)-well_notch_depth)>0     
	  */

	  /* 
	     inner pixel loop
	  */

	  for ( i_pixel=0;i_pixel<(end_y-start_y);i_pixel++)
	    {
	      /* copy column into the freec array */
	      freec[i_pixel] = image[(i_pixel*image_width)+i_column];
	      if ( freec[i_pixel] > well_depth )
		freec[i_pixel] = well_depth;
	      freec[i_pixel] -= well_notch_depth;
	      if ( freec[i_pixel] < 0.0 )
		freec[i_pixel] = 0.0;
	    }


	  /* clean the traps array */
	  
	  /* OLD C
	  for (i=0;i<n_levels;i++)
	    for (j=0;j<n_species;j++)
	      traps[(i*n_species)+j] = 0.0;
	  */
	  
	  /* optimized C */
	  for (i=0;i<n_levels*n_species;i++)
	    traps[i] = 0.0;
	  
	  /* traps are empty */
	  n_levels_traps = 0;
	  
      
	  /* output( 1, "max_height=%f\n", max_height ); */

	  for (i_pixel=0;i_pixel<(end_y-start_y);i_pixel++)
	    {

	      /* 
		 inner pixel loop
	      */

	      /* check if we need to calculate a new trail for that pixel */
	      if ( p_express_multiplier[i_pixel] != 0 )
		{

		  /*
		    Release any trapped electrons, using the appropriate decay half-life          
		  */

		  /* IDL
		    height=(total(total(traps[0:max_height-1,*],2) gt 0,/integer))>1

		    -> sum over all species entries and then counting all sum which are >0
		    the result is minimal 1 !
		  */

		  /* OLD C  */
		  height = 0;
		  for (i=0;i<n_levels_traps;i++)
		    {
		      sum = 0;
		      for (j=0;j<n_species;j++)
			sum += traps[(i*n_species)+j];
		      if ( sum > 0.0 )
			height++;
		    }
		  

		  
		  /* optimized C 
		  height = 0;
		  t = traps;
		  for (i=0;i<n_levels;i++)
		    {
		      sum = 0;
		      for (j=0;j<n_species;j++)
			{
			  sum += t[j];
			}
		      t += n_species;
		      if ( sum > 0.0 )
			height++;
		    }
		  if ( height < 1 )
		    height = 1;
		    
		  */

	      

		  /*
		    release=traps[0:height-1,*]*exponential_factor[0:height-1,*]
		    traps[0:height-1,*]-=release
		  */
		  
		  /* allocate release array */
		  /* release will have max n_species * n_levels elements */
		  release = malloc( n_species * height * sizeof( double ) );

		  /* OLD C
		  for (i=0;i<height;i++)
		    {
		      for (j=0;j<n_species;j++)
			{
			  int pos;
		      
			  pos = (i*n_species)+j;
			  release[pos] = traps[pos] * exponential_factor[pos];
		  
			  traps[pos] -= release[pos];
			}
		    } */

		  /* optimized C */
		  for (i=0;i<height*n_species;i++)
		    {		      
		      release[i] = traps[i] * exponential_factor[i];
		      traps[i] -= release[i];
		    }

		  if ( height > n_levels_traps )
		    {
		      n_levels_traps = height;
		      #ifdef __debug
		      output( 1, "height_level: %i\n", n_levels_traps );
		      #endif
		    }


		  /*  IDL
		     free[i_pixel]+=total(release)

		     sum of all release values
		  */
	  
		  sum = get_sum_double_array( release, height, n_species );

		  freec[i_pixel] += sum;
	  
		  #ifdef __debug
		  if ( i_pixel == 2000 )
		    {
		      output( 1, "before capture free_[i_pixel]=%f\n", freec[i_pixel] );
		    }
		  #endif

		  /*
		    Capture any free electrons in the vicinity of empty traps
		  */

		  if ( freec[i_pixel] > well_notch_depth )
		    {
		      /* IDL
			if free[i_pixel] gt well_notch_depth then begin
			height=n_levels*(0>(((free[i_pixel]-well_notch_depth)/well_range)^well_fill_power)<1)
		      */

		      d = pow(((freec[i_pixel] - well_notch_depth ) / well_range ),well_fill_power);
		      if ( d > 1.0 )
			d =  1.0;
		      else
			if ( d < 0.0 )
			  d = 0.0;

		      dheight = n_levels * d; 

	      
		      /* IDL
			height_frac=(height-indgen(ceil(height)))<1

			height_frac is a simple array, which elements are 1.0, except the last
			element which is <0, so that the sum over all elements is height!
		      */
		      cheight = ceil( dheight );

		      /*
			cheight will always be nlevels at max */

		      /* OLD C
			height_frac = indgen( cheight ); 
			for (i=0;i<cheight;i++)
			{
			height_frac[i] = dheight - height_frac[i];
			if ( height_frac[i] > 1.0 )
			height_frac[i] = 1.0;
			}
		      */

		      /* height_frac will be max n_levels + 1 elements large */
		      height_frac = gen_frac( cheight, dheight );

		      /* IDL 
		      	capture=0>((n_electrons_per_trap##height_frac)-traps[0:ceil(height)-1,*])
		      */

		      #ifdef __debug
		      if ( i_pixel == 2000 )
			{
			  output( 1, "dheight=%f\n", dheight );
			}
		      #endif


		      for (i=0;i<cheight;i++)
			{
			  for (j=0;j<n_species;j++)
			    {
			      int pos;
		      
			      pos = (i*n_species)+j;
		      
			      capture[pos] = (n_electrons_per_trap[j] * height_frac[i] ) - traps[pos];

			      if ( capture[pos] < 0.0 )
				capture[pos] = 0.0;
			    }
			}

		      /*
			total_capture=total(capture)>1e-14
			capture=temporary(capture)*((free[i_pixel]/total_capture)<1)
			traps[0:ceil(height)-1,*]+=capture
			free[i_pixel]-=total(capture)
		
			endif
		      */

		      total_capture = get_sum_double_array( capture, cheight, n_species );

		      #ifdef __debug
		      if ( i_pixel == 2000 )
			{
			output( 1, "total_capture1= %f\n", total_capture );
			} 
		      #endif
		  
		      if ( total_capture < 1e-14 )
			total_capture = 1e-14;
	      
		      /* do  ((free[i_pixel]/total_capture)<1) */

		      /* cannot capture more electrons than available */
		      d = freec[i_pixel] / total_capture;
		      if ( d < 1.0 )
			{
			  /* d is smaller than  1.0, so the multiplication makes some sense */
			  
			  /* OLD C
			  for (i=0;i<cheight;i++)
			    {
			      for (j=0;j<n_species;j++)
				{
				  int pos;
				  
				  pos = (i*n_species)+j;
				  capture[pos] *= d;
				}
			    }
			  */
			  
			  for (i=0;i<cheight*n_species;i++)
			    capture[i] *= d;

			}

		      
		      /* change the traps */

		      /* OLD C
		      for (i=0;i<cheight;i++)
			{
			  for (j=0;j<n_species;j++)
			    {
			      int pos;
			      
			      pos = (i*n_species)+j;
			      traps[pos] += capture[pos];
			    }
			}  
		      */


		      /* optimized C */
		      for (i=0;i<cheight*n_species;i++)
			traps[i] += capture[i];
		      
		      if ( cheight > n_levels_traps )
			{
			  n_levels_traps = cheight;
			  #ifdef __debug
			  output( 1, "cheight_level: %i\n", n_levels_traps );
			  #endif
			}

		      total_capture = get_sum_double_array( capture, cheight, n_species );
		  
		      freec[i_pixel] -= total_capture;

		      #ifdef __debug
		      /* DBEUG */
		      if ( i_pixel == 2000 )
			output( 1, "free[i_pixel] = %f\n", freec[i_pixel] );
		      #endif

		      free( height_frac );

		      free( release );
		    }

		}  /* endif of express_multiplier != 0 */

	    } /* i_pixel loop */ 


	  /*  Evaluate the delta trail, and add it to the image */

	  /*
	    trail=(temporary(free)-double(((image[i_column,yrange[0]:yrange[1]]<well_depth)-well_notch_depth)>0))*express_multiplier[i_express,yrange[0]:yrange[1]]
	    if yrange[0] eq 0 then image[i_column,yrange[0]:yrange[1]]+=trail else image[i_column,yrange[0]+1:yrange[1]]+=trail[1:*]

	  */
	  for ( i_pixel=0;i_pixel<(end_y-start_y);i_pixel++)
	    {
	      /* check if we need to calculate a new trail for that pixel */
	      if ( p_express_multiplier[i_pixel] != 0 )
		{
		  d = image[((i_pixel+start_y)*image_width)+i_column];
		  if ( d > well_depth )
		    d = well_depth;
		  d -= well_notch_depth;
		  if ( d < 0.0 )
		    d = 0.0;

		  
		  trail[i_pixel] = ( freec[i_pixel] - d ) * p_express_multiplier[i_pixel];

		  /*if ( i_pixel < 11 )
		    {
		    output( 1, "im=%f\n", image[(i_pixel*image_width)+i_column] );
		    output( 1, "d=%f\n", d );
		    output( 1, "t=%f\n", trail[i_pixel] );
		    } */

		  /* DEBUG 
		  if ( i_pixel == 2000 )
		    {
		      output( 1, "double=%f\n", d );
		      d = freec[i_pixel] - d;
		      output( 1, "double2=%.10f\n",  d );
		      output( 1, "double3=%.10f\n",  ( d * p_express_multiplier[i_pixel] ) );
		      output( 1, "image[i_column,i_pixel] = %f\n", image[((i_pixel+start_y)*image_width)+i_column] );
		      } */

		  image[((i_pixel+start_y)*image_width)+i_column] += trail[i_pixel];

		  #ifdef __debug
		  /* DEBUG */
		  if ( i_pixel == 2000 )
		    {
		      output( 1, "trail[i_pixel] = %f\n", trail[i_pixel] );
		      output( 1, "image[i_column,i_pixel] = %f\n", image[((i_pixel+start_y)*image_width)+i_column] );
		    }
		  #endif

		  /*if ( i_pixel < 11 )
		    {
		    output( 1, "im2=%f\n", image[(i_pixel*image_width)+i_column] );
		    } */
		}
	    } /* i_pixel loop for the trail */
	}  /* end of express loop */

	  
      p_express_multiplier += image_height +1;


      /* time measurement */
      if ( ( i_column % 200 ) == 0 ) 
	{
	  gettimeofday( &temp_time, NULL );
	  getrusage( RUSAGE_SELF, &cpu_temp_time);
	  diff_time = get_difftime( start_time, temp_time );
	  cpu_diff_time = get_difftime( cpu_start_time.ru_utime, cpu_temp_time.ru_utime );
	  eta_time = ( diff_time / ( (i_column+1) - start_x ) ) * ( end_x - start_x );
	  /*output( 1, "Clocking column #%i/%i in %fs, or %fs/column. ETA %fs.\n", 
		  i_column+1, ( end_x - start_x ),
		  diff_time,
		  ( diff_time / ( ( i_column + 1 ) - start_x ) ),
		  ( eta_time - diff_time ) ); */
	  output( 1, "Clocking column #%i/%i in %fs, or %fs/column. ETA %.1fs.\n", 
		  i_column+1, ( end_x - start_x ),
		  cpu_diff_time,
		  ( cpu_diff_time / ( ( i_column + 1 ) - start_x ) ),
		  ( eta_time - diff_time ) );
	  
	} 
	
    } /* end of i_column loop */
  
  /* final time measurement */
  gettimeofday( &temp_time, NULL );
  getrusage( RUSAGE_SELF, &cpu_temp_time);
  diff_time = get_difftime( start_time, temp_time );
  cpu_diff_time = get_difftime( cpu_start_time.ru_utime, cpu_temp_time.ru_utime );
  /*output( 1, "Clocking column #%i/%i in %fs, or %fs/column. (TOTAL)\n",
	  end_x, end_x,
	  diff_time,
	  ( diff_time  / ( end_x - start_x ) ) );  */

  output( 1, "Clocking #%i finished  in %fs REALTIME (CPU: %.2f%%)\n", 
	  (end_x - start_x), diff_time, (( cpu_diff_time / diff_time ) * 100.0 ) );
  output( 1, "                          %fs CPU TIME, or %fs/column\n", 
	  cpu_diff_time, ( cpu_diff_time  / ( end_x - start_x ) ) );
  
  /* free local variables */
  free( capture );
  free( trail );
  free( freec );
  free( traps );
  free( exponential_factor );
  free( express_multiplier );
  free( n_electrons_per_trap );
}
